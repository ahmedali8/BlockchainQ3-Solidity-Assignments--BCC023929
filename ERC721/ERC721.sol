pragma solidity ^0.6.0;

import "./IERC721.sol";
import "./IERC721Metadata.sol";
import "./ERC165.sol";
import "./SafeMath.sol";
import "./Address.sol";
import "./Strings.sol";


/**
 * @title ERC721 Non-Fungible Token Standard basic implementation
 * @dev see https://eips.ethereum.org/EIPS/eip-721
 */
contract ERC721 is IERC721, IERC721Metadata, ERC165 {
    
    // SafeMath library will allow to use arthemtic operation on uint256
    using SafeMath for uint256;
    
    // Extending address with Address Library, will alow to check EOA or contract addresses.
    using Address for address;
    
    // Converts a `uint256` to its ASCII `string` representation.
    using Strings for uint256;
    
    
    uint256 _totalSupply;
    
    
    // mapping from owner address to their set of all owned tokens
    mapping(address => uint256[]) private _ownerTokens;
    
    // mapping from token Ids to their owners
    mapping(uint256 => address) private _tokenOwners;
    
    // mapping for holding index of token ids of an owner
    mapping(address => mapping(uint256 => uint256)) private _ownerTokenIndex;
    
    // mapping from specific token Id to an approved address
    mapping(uint256 => address) private _tokenApprovals;
    
    /**
    * For a given account (owner), for a given operator, store whether that operator is
    * allowed to transfer and modify all assets (tokens) on behalf of them(owner)
    */
    mapping(address => mapping(address => bool)) private _operatorApprovals;
    
    // optional mapping for holding tokenURIs of token Ids 
    mapping(uint256 => string) private _tokenURIs;
    
    
    // Token name
    string private _name;
    
    // Token symbol
    string private _symbol;
    
    // Base URI
    string private _baseURI;
    
    
    // bytes4 for verification through ERC165 
    /*
     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231
     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e
     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3
     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc
     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465
     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5
     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd
     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e
     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde
     *
     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^
     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd
     */
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /*
     *     bytes4(keccak256('name()')) == 0x06fdde03
     *     bytes4(keccak256('symbol()')) == 0x95d89b41
     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd
     *
     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f
     */
    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;

    /*
     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd
     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59
     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7
     *
     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63
     */
    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;
    
    
    
    
    /**
     * @dev runs only once when contract is deployed
     * @param name - set the name of token.
     * @param symbol - set the symbol of token.
     */
    constructor(string memory name, string memory symbol) public {
        _name = name;
        _symbol = symbol;
        
        // Register the supported interfaces to conform to ERC721 via ERC165 
        // i.e. verification of ERC721 through ERC165
        _registerInterface(_INTERFACE_ID_ERC721);
    }
    
    
    
    
    /**
     * @dev See {IERC721Metadata-name}.
     * 
     * @dev Gets the token name.
     * @return string representing the name.
     */
    function name() public view override returns (string memory) {
        return _name;
    } 
    
    /**
     * * @dev See {IERC721Metadata-symbol}.
     * 
     * @dev Gets the token symbol.
     * @return string representing the symbol.
     */
    function symbol() public view override returns (string memory) {
        return _symbol;
    } 
    
    /**
     * * @dev See {IERC721Metadata-tokenURI}.
     * 
     * * @dev Returns the URI for a given token ID. May return an empty string.
     *
     * If a base URI is set (via {_setBaseURI}), it is added as a prefix to the
     * token's own URI (via {_setTokenURI}).
     *
     * If there is a base URI but no token URI, the token's ID will be used as
     * its URI when appending it to the base URI. This pattern for autogenerated
     * token URIs can lead to large gas savings.
     *
     * .Examples
     * |===
     * |`_setBaseURI()` |`_setTokenURI()` |`tokenURI()`
     * | ""
     * | ""
     * | ""
     * | ""
     * | "token.uri/123"
     * | "token.uri/123"
     * | "token.uri/"
     * | "123"
     * | "token.uri/123"
     * | "token.uri/"
     * | ""
     * | "token.uri/<tokenId>"
     * |===
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     * 
     * @return string representing the tokenURI.
     */
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        
        string memory _tokenURI = _tokenURIs[tokenId];
        
        // if there is no baseURI, return the tokenURI.
        if(bytes(_baseURI).length == 0) {
            return _tokenURI;
        }
        // if both are set, concatenate the _baseURI and _tokenURI (via abi.encodePacked). 
        else if(bytes(_baseURI).length > 0) {
            return string(abi.encodePacked(_baseURI, _tokenURI));
        }
        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.
        else {
            return string(abi.encodePacked(_baseURI, tokenId.toString()));
        }
    } 
    
    /**
    * @dev Returns the base URI set via {_setBaseURI}. This will be
    * automatically added as a prefix in {tokenURI} to each token's URI, or
    * to the token ID if no specific URI is set for that token ID.
    */
    function baseURI() public view returns (string memory) {
        return _baseURI;
    }
    
    /**
     * @dev Gets the total amount of tokens stored by the contract.
     * @return uint256 representing the total amount of tokens.
     */
    function totalSupply() public view  returns (uint256) {
        return _totalSupply;
    }
    
    /**
     * @dev See {IERC721-balanceOf}.
     * 
     * @dev Gets the balance of the specified address 
     * by using _ownerTokens mapping.
     * 
     * @param owner - address to query the balance of
     * @return uint256 - representing the amount owned by the passed address
     */
    function balanceOf(address owner) public view override returns (uint256) {
        require(owner != address(0), "ERC721: balance query for the zero address");
        
        return _ownerTokens[owner].length;
    }
    
    /**
     * @dev See {IERC721-ownerOf}.
     * 
     * @dev Gets the owner of the specified token ID 
     * by using _tokenOwners mapping.
     * 
     * @param tokenId - uint256 ID of the token to query the owner of
     * @return address - currently marked as the owner of the given token ID
     */
    function ownerOf(uint256 tokenId) public view override returns (address) {
        require(tokenId > 0,"ERC721: Token does not exist");
        address owner = _tokenOwners[tokenId];
        require(owner != address(0), "ERC721: owner query for nonexistent token");
        
        return owner;
    }
    
    /**
     * @dev Gets the token ID at a given index of the tokens list of the requested owner
     * by using _ownerTokens mapping.
     * 
     * @param owner address owning the tokens list to be accessed
     * @param index - uint256 representing the index to be accessed of the requested tokens list
     * @return uint256 - token ID at the given index of the tokens list owned by the requested address
     */
    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {
        require(owner != address(0), "ERC721: owner query for nonexistent token");
        
        return _ownerTokens[owner][index];
    }
    
    /**
     * @dev Gets index of particular token ID from Owner's collection
     * by using _ownerTokenIndex nested mapping.
     * 
     * @param owner - address of token owner. 
     * @param tokenId - uint256 ID of the token to query the index of
     * @return uint256 - index of that specified token
     */
    function indexOfOwnerToken(address owner, uint256 tokenId) public view returns (uint256){
        require(owner != address(0), "ERC721: owner query for nonexistent token");
        require(tokenId > 0,"ERC721: Query for non existent token");
        
        return _ownerTokenIndex[owner][tokenId];
    }
    
    /**
     * @dev See {IERC721-approve}.
     * 
     * @dev Approves another address to transfer the given token ID
     * 
     * Requirements:
     * 
     * - The zero address indicates there is no approved address.
     * - There can only be one approved address per token at a given time.
     * - Can only be called by the token owner or an approved operator.
     * 
     * @param to - address to be approved for the given token ID
     * @param tokenId - uint256 ID of the token to be approved
     */
    function approve(address to, uint256 tokenId) public virtual override {
        address owner = ownerOf(tokenId);
        require(to != owner, "ERC721: approval to current owner");
        
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender),
            "ERC721: approve caller is not owner nor approved for all"
        );
        
        // calling internal function to update _tokenApprovals mapping
        _approve(to, tokenId);
    }
    
    /**
     * @dev See {IERC721-getApproved}.
     * 
     * @dev Gets the approved address for a token ID, or error if no address set
     * Reverts if the token ID does not exist.
     * 
     * @param tokenId - uint256 ID of the token to query the approval of
     * @return address - current address approved for the given token ID
     */
    function getApproved(uint256 tokenId) public view override returns (address) {
        require(_exists(tokenId), "ERC721: approved query for nonexistent token");
        require(_tokenApprovals[tokenId] == address(0), "ERC721: no approved address set by owner");
        
        return _tokenApprovals[tokenId];
    }
    
    /**
     * @dev See {IERC721-setApprovalForAll}.
     * 
     * @dev Sets or unsets the approval of a given operator
     * An operator is allowed to transfer all tokens of the sender on their behalf.
     * 
     * @param operator - operator address to set the approval
     * @param approved - bool representing the status of the approval to be set
     */
    function setApprovalForAll(address operator, bool approved) public virtual override {
        // msg.sender would be the owner of tokens
        require(operator != msg.sender, "ERC721: approve to caller");
        require(operator != address(0), "ERC721: approval query for zero address");

        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
    
    /**
     * @dev See {IERC721-isApprovalForAll}.
     * 
     * @dev Tells whether an operator is approved by a given owner.
     * 
     * @param owner - owner address which you want to query the approval of
     * @param operator - operator address which you want to query the approval of
     * @return bool whether the given operator is approved by the given owner
     */
    function isApprovedForAll(address owner, address operator) public view override returns (bool) {
        return _operatorApprovals[owner][operator];
    }
    
    /**
     * @dev Transfers the ownership of a given token ID to another address.
     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
     * Requires the msg.sender to be the owner, approved, or operator.
     * 
     * @param to - address to receive the ownership of the given token ID
     * @param tokenId - uint256 ID of the token to be transferred
     */
    function transfer(address to, uint256 tokenId) public virtual {
        require(_isApprovedOrOwner(msg.sender, tokenId), "ERC721: transfer caller is not owner nor approved");
        address from = msg.sender;
        _transfer(from, to, tokenId);
    }
    
    /**
     * @dev See {IERC721-transferFrom}.
     * 
     * @dev Transfers the ownership of a given token ID to another address.
     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
     * 
     * Requirements:
     * 
     * - Requires the msg.sender to be the owner, approved, or operator.
     * 
     * @param from - current owner of the token
     * @param to - address to receive the ownership of the given token ID
     * @param tokenId - uint256 ID of the token to be transferred
     */
    function transferFrom(address from, address to, uint256 tokenId) public virtual override {
        require(_isApprovedOrOwner(msg.sender, tokenId), "ERC721: transfer caller is not owner nor approved");

        _transfer(from, to, tokenId);
    }
    
    
    
    
    // Internal functions:
    
    /**
     * @dev Internal function that Returns whether the specified token
     * exists or not by using _ownerTokens mapping.
     * 
     * @param tokenId - uint256 ID of the token to query the existence of
     * @return bool - whether the token exists
     */
    function _exists(uint256 tokenId) internal view returns (bool) {
        require(tokenId > 0,"ERC721: Token does not exist");
        address owner = _tokenOwners[tokenId];
        
        if(owner != address(0)) {
            return true;
        }    
        else {
            return false;
        }    
    }
    
    /**
     * @dev Internal function that Returns whether the given spender can transfer a given token.
     * 
     * @param spender - address of the spender to query
     * @param tokenId - uint256 ID of the token to be transferred
     * @return bool - whether the msg.sender is approved for the given token ID,
     * is an operator of the owner, or is the owner of the token 
     */
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), "ERC721: operator query for nonexistent token");
        address owner = ownerOf(tokenId);
        return (spender == getApproved(tokenId) || isApprovedForAll(owner, spender) || spender == owner);
    } 
    
    /**
     * @dev Internal function to transfer ownership of a given token ID to another address.
     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
     * 
     * @param from - current owner of the token
     * @param to - address to receive the ownership of the given token ID
     * @param tokenId - uint256 ID of the token to be transferred
     */
    function _transfer(address from, address to, uint256 tokenId) internal virtual {
        require(tokenId > 0, "ERC721: Invalid tokenId - tokenId can't be zero");
        require(ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");
        require(to != address(0), "ERC721: transfer to the zero address");
        
        
        // Clear approvals from the previous owner
        _approve(address(0), tokenId);
        
        // delete of from address
        _deleteToken(from,tokenId);
        
        // adding new token
        _addToken(to,tokenId);
        
        emit Transfer(from, to, tokenId);
    }
    
    /**
     * @dev Internal function to delete token safely
     * 
     * Requirements:
     * 
     * - Token should already exist
     * - Token should be owned by owner
     * 
     * @param owner - address of owner, owns a token
     * @param tokenId - uint256 ID of the token
     * @return success - bool value whether successful or not
     * @return index - uint256 value of index whose token is deleted
     * 
     */
    function _deleteToken(address owner, uint256 tokenId) internal virtual returns (bool success, uint256 index) {
        require(_exists(tokenId), "ERC721: Invalid Token - Token does not exist");
        require(_tokenOwners[tokenId] == owner, "ERC721: Invalid ownership - Token is not owned by owner");
        
        index = _ownerTokenIndex[owner][tokenId];
        
        // more than one token then swap the lastIndex token to current index
        if(_ownerTokens[owner].length > 1) {
            uint256 lastIndex = (_ownerTokens[owner].length).sub(1);
            uint256 lastToken = _ownerTokens[owner][lastIndex];
            
            // updating the lastToken to current index _ownerTokens and _ownerTokenIndex mappings
            _ownerTokens[owner][index] = lastToken;
            _ownerTokenIndex[owner][lastToken] = index;
        }
        
        // remove last entry
        _ownerTokens[owner].pop();
        
        // remove owner of tokenId from _tokenOwners
        delete _tokenOwners[tokenId];
        
        // remove index of tokenId from _ownerTokenIndex
        delete _ownerTokenIndex[owner][tokenId];
        
        success = true;
    }
    
    /**
     * @dev Internal function to add token safely
     * 
     * Requirements:
     * 
     * - Token should not already exist
     * - Token should not be owned by owner
     * 
     * @param owner - address of owner, owns a token
     * @param tokenId - uint256 ID of the token
     * @return success - bool value whether successful or not
     * @return newIndex - uint256 value of index whose token is deleted
     * 
     */
    function _addToken(address owner, uint256 tokenId) internal virtual returns (bool success, uint256 newIndex) {
        require(!_exists(tokenId), "ERC721: Token already exist");
        require(_tokenOwners[tokenId] != owner, "ERC721: Owner already owned token");
        
        // assign token to owner
        _tokenOwners[tokenId] = owner;
        
        // push new token into owner's posession
        _ownerTokens[owner].push(tokenId);
        
        // store new index in _ownerTokenIndex
        newIndex = (_ownerTokens[owner].length).sub(1); // lastIndex which we just pushed
        _ownerTokenIndex[owner][tokenId] = newIndex;
        
        success = true;
    }
    
    /**
     * @dev Internal function to mint a new token.
     * 
     * Reverts if the given token ID already exists.
     * 
     * @param to - The address that will own the minted token
     * @param tokenId - uint256 ID of the token to be minted
     */
    function _mint(address to, uint256 tokenId) internal virtual {
        require(to != address(0), "ERC721: mint to the zero address");
        require(!_exists(tokenId), "ERC721: token already minted");
        
        // increment _totalSupply
        _totalSupply = _totalSupply.add(1);
        
        // state update on adding token
        _addToken(to,tokenId);
        
        emit Transfer(address(0), to, tokenId);
    }
    
    /**
     * @dev Internal function to burn a specific token.
     * 
     * Reverts if the token does not exist.
     * 
     * @param tokenId - uint256 ID of the token being burned
     */
    function _burn(uint256 tokenId) internal virtual {
        require(_exists(tokenId), "ERC721: burn query for nonexistent token");
        address owner = ownerOf(tokenId);
        
        // Clear approvals
        _approve(address(0), tokenId);
        
        // Clear metadata (if any)
        if(bytes(_tokenURIs[tokenId]).length != 0) {
            delete _tokenURIs[tokenId];
        }
        
        // decrement _totalSupply
        _totalSupply = _totalSupply.sub(1);
        
        //state update on token delete
        _deleteToken(owner,tokenId);
        
        emit Transfer(owner, address(0), tokenId);
    }
    
    /**
     * @dev Internal function to set the base URI for all token IDs. It is
     * automatically added as a prefix to the value returned in {tokenURI},
     * or to the token ID if {tokenURI} is empty.
     */
    function _setBaseURI(string memory baseURI_) internal virtual {
        _baseURI = baseURI_;
    }
    
    /**
     * @dev Internal function to set the token URI for a given token.
     *
     * Reverts if the token ID does not exist.
     *
     * TIP: If all token IDs share a prefix (for example, if your URIs look like
     * `https://api.myproject.com/token/<id>`), use {_setBaseURI} to store
     * it and save gas.
     */
    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {
        require(_exists(tokenId), "ERC721Metadata: URI set of nonexistent token");
        _tokenURIs[tokenId] = _tokenURI;
    }
    
    
    
    
    // Private functions:
    
    /**
     * @dev Private function that approves an address to transfer a specified token
     * by using _tokenApprovals mapping.
     * 
     * @param to - address to be approved for the specified tokenId 
     * @param tokenId - uint256 ID of the token to be approved
     */
    function _approve(address to, uint256 tokenId) private {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }
    
}